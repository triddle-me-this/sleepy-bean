package tmx;

import java.awt.Color;
import java.io.File;
import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import core.physics.Point;

//For use specifically reading .TMX files generated by the level editing program "Tiled".
public class TmxReader {
	
	
	//Reads a particular attribute of the main map object of a given file and returns it as a string.
	public static String readMapAttribute(File xmlFile, String attribute){
		
		NodeList firstLevelNodes = getFirstLayerNodes(xmlFile);
		Node mapNode = findMapNode(firstLevelNodes);
		
		Element mapElement = (Element)mapNode;
		String string = mapElement.getAttribute(attribute);
		return string;
	}
	
	//Reads a particular attribute of the main map object of the file at the given path and returns it as a string.
	public static String readMapAttribute(String filePath, String attribute){
		
		File xmlFile = new File(filePath);
		return readMapAttribute(xmlFile, attribute);
		
	}
	
	//returns the width of the map (in tiles).
	public static int readMapWidth(File xmlFile){
		
		String stringWidth = readMapAttribute(xmlFile, "width");
		int width = Integer.parseInt(stringWidth);
		return width;
		
	}
	
	//returns the height of the map (in tiles).
	public static int readMapHeight(File xmlFile){
		
		String stringHeight = readMapAttribute(xmlFile, "height");
		int height = Integer.parseInt(stringHeight);
		
		return height;
	}
	
	//returns the height of each individual tile.
	public static int readTileHeight(File xmlFile){
		
		String stringHeight = readMapAttribute(xmlFile, "tileheight");
		int tileHeight = Integer.parseInt(stringHeight);
		
		return tileHeight;
	}
	
	//returns the width of each individual tile.
	public static int readTileWidth(File xmlFile){
		
		String stringWidth = readMapAttribute(xmlFile, "tilewidth");
		int tileWidth = Integer.parseInt(stringWidth);
		return tileWidth;
	}
	
	//returns the version of the map.
	public static double readMapVersion(File xmlFile){
		
		String stringVersion = readMapAttribute(xmlFile, "version");
		double version = Double.parseDouble(stringVersion);
		return version;
	}
	
	//returns the orientation of the map.
	public static String readMapOrientation(File xmlFile){
		
		String orientation = readMapAttribute(xmlFile, "orientation");
		return orientation;
	}
	
	//reads the background color of the map, converts it to a normal RGB Java color and returns it.
	public static Color readMapBackgroundColor(File xmlFile){
		
		String hexColor = readMapAttribute(xmlFile, "backgroundcolor");
		
		String hexRed = hexColor.substring(1, 3);
		Long Lr = Long.parseLong(hexRed, 16);
		
		String hexGreen = hexColor.substring(3, 5);
		Long Lg = Long.parseLong(hexGreen, 16);
		
		String hexBlue = hexColor.substring(5, 7);
		Long Lb = Long.parseLong(hexBlue, 16);

		int r = Lr.intValue();
		int g = Lg.intValue();
		int b = Lb.intValue();
		
		Color color = new Color(r,g,b);
		return color;
	}
	
	
	//Iterates through the data, organizes it into Layer objects, and returns a list of those layers.
	//"Deepest" layers will end up at the bottom of the list so draw order is correct from the beginning.
	public static ArrayList<TmxLayer> readLayers(File xmlFile){
		
		ArrayList<TmxLayer> layerList = new ArrayList<TmxLayer>();
		
		NodeList firstLevelNodes = getFirstLayerNodes(xmlFile);
		Node mapNode = findMapNode(firstLevelNodes);
		ArrayList<Node> layerNodes = findLayerNodes(mapNode);
		for (Node layerNode: layerNodes){
			
			Element layerElement = (Element)layerNode;
			String layerName = (layerElement.getAttribute("name"));
			
			
			Node dataNode = getDataNode(layerNode);
			layerList.add(new TmxLayer(layerName, dataNode));
		}
		
		return layerList;
	}
	
	//Tries to return a data Node from a (supposed) layerNode. If a data node can't be found, returns null.
	public static Node getDataNode(Node layerNode){
		
		NodeList possibleDataNodes = layerNode.getChildNodes();
		for (int index = 0; index<possibleDataNodes.getLength(); index++){
			Node possibleNode = possibleDataNodes.item(index);
			if (possibleNode.getNodeName()=="data"){
				return possibleNode;
			}
		}
		
		return null;
	}
	
	
	//takes an XML file and returns a nodeList of the "first-level" nodes.
	//if something fails, return null.
	//In the case of normal TMX files, the map node should be the only "first-level node".
	public static NodeList getFirstLayerNodes(File xmlFile){
		
		try{
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder documentBuilder = dbFactory.newDocumentBuilder();
			Document doc = documentBuilder.parse(xmlFile);
			
			doc.getDocumentElement().normalize();
			
			NodeList firstNodes = doc.getChildNodes();
			return firstNodes;
			
		} catch (Exception e){
			e.printStackTrace();
		}
		
		return null;
		
	}

	
	//Tries to return a map node from the first layer.
	//If there is no map node in the first layer, returns null.
	public static Node findMapNode(NodeList firstNodes){
		try{
			for (int i=0; i< firstNodes.getLength(); i++){
				
				Node firstNode = firstNodes.item(i);
				if (firstNode.getNodeName() == "map"){
					return firstNode;
				}
			}
		} catch (Exception e){
			e.printStackTrace();
		}
		
		return null;
	}
	
	//Scans all the nodes one level deeper than the map.
	//If any of the scanned nodes are "layer" nodes, they are added to a List which is returned.
	public static ArrayList<Node> findLayerNodes(Node mapNode){
		
		ArrayList<Node> arrayNodes = new ArrayList<Node>();
		
		NodeList possibleLayerNodes = mapNode.getChildNodes();
		for (int index=0; index<possibleLayerNodes.getLength(); index++){
			Node possibleNode = possibleLayerNodes.item(index);
			if (possibleNode.getNodeName()=="layer"){
				arrayNodes.add(possibleNode);
			}
		}
		
		return arrayNodes;
	}
	
	//Counts in rows across a coordinate based map. When the end of a row is reached
	//it begins counting at the start of the next row. 
	//ex: In a map width of 5, 6 would return as (0, 1).
	public static Point countToCoords(int count, int width){

		int remainder = count % width;
		if (remainder ==0)
			remainder = width;
		remainder --;
		
		int numRows = (count - remainder)/width;
		numRows --;
		
		return new Point(remainder, numRows);
	}
}


